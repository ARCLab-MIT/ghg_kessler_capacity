'''
FILE DESCRIPTION: This script loads in the density forecast data for the various SSPs and the baseline, 
then uses these time and altitude-resolved densities to compute the altitude at which an object 
of interest (with ballisitic coefficient of interest) will deorbit within a desired time frame. 
Here, we consider 5 and 25-year deorbit timeframes. The baseline case shows changes in the operational
altitude for the reference object due to the solar cycle alone, while the SSP cases show the impact of 
greenhouse gasses on deorbit timelines. 

The atmospheric mass density profile is located in data/dens_forecast_ssp_v2_msis2.mat.

This script will search for files generated by previous runs with the default conditions. If you modify the parameters,
it will automatically re-run the code to generate and plot new results. 

11/20/2024 - William Parker
'''
import pickle as pkl
import numpy as np
import matplotlib.pyplot as plt
import scipy.io as sio
import os
from scipy.optimize import minimize

# make all the font arial
plt.rcParams['font.sans-serif'] = "Arial"
plt.rcParams['font.family'] = "sans-serif"
# make font gray
plt.rcParams['text.color'] = 'gray'
plt.rcParams['axes.labelcolor'] = 'gray'
plt.rcParams['xtick.color'] = 'gray'
plt.rcParams['ytick.color'] = 'gray'
# make the box around the plot gray
plt.rcParams['axes.edgecolor'] = 'white'

def main():
    # First, check to see if the deorbit altitude data has already been computed. If it has, load it. If not, compute it.
    fname1 = 'data/alt_ref_5y_30_10_v3.pkl'
    fname2 = 'data/alt_ref_25y_30_10_v3.pkl'
    if os.path.isfile(fname1) and os.path.isfile(fname2):
        with open(fname1, 'rb') as f:
            alt_5y = pkl.load(f)
        with open(fname2, 'rb') as f:
            alt_25y = pkl.load(f)

    else:
        # load processed file with time and altitude-resolved density profiles for each of the SSPs. 
        processed_file = 'data/dens_forecast_ssp_v3_msis2.pkl'

        # load data from pkl
        data = pkl.load(open(processed_file, 'rb'))
        dens_ssp1_19_rs = data[0]
        dens_ssp1_26_rs = data[1]
        dens_ssp2_45_rs = data[2]
        dens_ssp3_70_rs = data[3]
        dens_ssp3_70_lowNTCF_rs = data[4]
        dens_ssp4_34_rs = data[5]
        dens_ssp4_60_rs = data[6]
        dens_ssp5_34_over_rs = data[7]
        dens_ssp5_85_rs = data[8]
        dens_rs = data[9]
        alt_rs = data[10]
        year_rs = data[11]
        
        ssp_arrays = [dens_ssp1_26_rs, dens_ssp2_45_rs, dens_ssp5_85_rs, dens_rs, year_rs, alt_rs]

        # Call the function
        ssp_array_names = ['SSP1-26', 'SSP2-45', 'SSP5-85', 'Baseline', 'year_rs', 'alt_rs']
        
        # make a dictionary that contains the arrays
        ssp_dict = {}
        for i, ssp_array in enumerate(ssp_arrays):
            ssp_dict[ssp_array_names[i]] = ssp_array
        
        # initialize satellite properties
        r_e = 6378.137 # Earth radius in km
        mu = 398600 # Earth gravitational parameter in km^3/s^2
        B = 0.02/1e6 # ballistic coefficient in km^2/kg    
        t0 = 2000
        alt = 500
        day_s = 23.9344500*3600
        dt = 10*day_s # time step in seconds
        
        # test deorbit time calculator: 
        t_deb_decay = t_to_deorbit(alt, t0, B, mu, r_e, dt, ssp_dict, ssp_array_names[0])  
        print('Decay time for satellite at altitude', alt, 'km is', t_deb_decay/3600/23.9344, 'days, or' , t_deb_decay/3600/23.9344/365.25, 'years')

        # compute the altitude for which the deorbit time is closest to the target time 
        year_s = 365.25*23.9344500*3600
        t_deorbit_target = [5*year_s, 25*year_s]
        labels = ['alt_5y', 'alt_25y']
        start_alt_guess = 500 
        
        # for each timestep, compute the altitude where the de-orbit time is closest to 5 years
        for k in range(len(t_deorbit_target)): 
            if k == 0:
                t0_vec = np.arange(2000,2095, 1/12) # time vector of query points
            elif k == 1:
                t0_vec = np.arange(2000,2075, 1/12)
            else: 
                print('Invalid target time')
            alt_ref = np.zeros((4,len(t0_vec)))
            for j in range(4):
                for i in range(len(t0_vec)):
                    alt_ref[j,i] = minimize(lambda x: np.abs(t_to_deorbit(x, t0_vec[i], B, mu, r_e, dt, ssp_dict, ssp_array_names[j]) - t_deorbit_target[k]), start_alt_guess, method='Nelder-Mead').x[0]
                    # print(i/len(t0_vec))
                if j in [0,1,2]: 
                    alt_ref[j,:] = alt_ref[j,:]
                print('Done with', ssp_array_names[j], 'for', t_deorbit_target[k]/year_s, 'years')

            with open('data/alt_ref_'+str(int(t_deorbit_target[k]/year_s))+'y_'+str(round(abs(t0_vec[1]-t0_vec[0])*365.25)) + '_' + str(round(dt/day_s)) + '_v3.pkl', 'wb') as f:
                pkl.dump(alt_ref, f)

            if k == 0:
                alt_5y = alt_ref
            elif k == 1:
                alt_25y = alt_ref
        
    #  Plot the results!
    colors = ['#00798c', '#edae49', '#d1495b', 'k', '#6a4c93']
    ssp_array_names = ['SSP1-2.6', 'SSP2-4.5', 'SSP5-8.5', 'Baseline', 'year_rs', 'alt_rs']

    t0_vec = np.arange(2000,2095, 1/12)
    plt.figure(figsize = (8,4))
    start_year = 1947.7
    end_year = 2105
    interval = 10.93
    current_year = start_year
    while current_year <= end_year:
        plt.axvline(current_year, color='gainsboro', linestyle='-', linewidth=0.5)
        current_year += interval
    plt.plot(t0_vec, alt_5y[3,:], ':', color = 'k', label = ssp_array_names[3], linewidth = 1)
    for j in range(3):
        plt.plot(t0_vec, alt_5y[j,:], '-', color = colors[j], label = ssp_array_names[j], linewidth = 1)
    plt.plot(t0_vec, alt_5y[3,:], ':', color = 'k', linewidth = 1)
    plt.axvspan(1981, 2023.5, color = 'whitesmoke')

    t0_vec = np.arange(2000,2075, 1/12)
    plt.plot(t0_vec, alt_25y[3,:], ':', color = 'k', linewidth = 1)
    for j in range(3):
        plt.plot(t0_vec, alt_25y[j,:], '-', color = colors[j],linewidth = 1)

    plt.xlabel('Deorbit Start Year')
    plt.xlim([1981,2100])
    plt.ylabel('Altitude [km]')
    plt.legend(loc = 'upper right')
    plt.grid(axis = 'y', color = 'gainsboro', linewidth = 0.5) 
    plt.tick_params(axis='y', which='both', left=False, right=False)
    plt.tight_layout()
    plt.savefig('figs/alt_deorbit.png', dpi = 600)
    plt.show()
    
def t_to_deorbit(alt,t0,  B, mu, r_e, dt, ssp_dict, ssp):
    # compute the estimated time it will take for satellite to deorbit
    t_step = dt
    v = np.sqrt(mu/(r_e+alt))
    t = t0
    max_time = 1000*365.25*23.9344*3600
    for i in range(int(max_time/t_step)): # 1000 years max
        dens = den(alt, t,  ssp_dict,ssp)
        a_drag = -0.5  * dens*1e9 * v**2 *B
        T = 2*np.pi*np.sqrt((r_e+alt)**3/mu)
        dalt_dt = a_drag*T/np.pi # https://en.wikipedia.org/wiki/Orbital_decay
        # propagate forward 
        alt = alt + dalt_dt*t_step
        t = t0 + t_step/(23.9344*3600*365.25)*i
        if alt < 100:
            decay_time = t_step*i
            return decay_time
    return(max_time)

def den(alt, t,  ssp_dict, ssp):
    # compute density at this altitude
    ssp_query = ssp_dict[ssp]
    # query the density for the value closest to this altitude and time
    alt_closest = np.argmin(np.abs(ssp_dict['alt_rs']-alt))
    year_closest = np.argmin(np.abs(ssp_dict['year_rs']-t))
    dens = ssp_query[year_closest, alt_closest]
    return dens

if __name__ == '__main__':
    main()